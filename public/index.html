<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>tracking.js</title>
    <script src="gsap.min.js"></script>
    <style>
        html, body {
            margin: 0;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        img { position: absolute; }
    </style>
</head>
<body>
<img id="black" src="black.png" width="300" height="300" alt="">

<script>
    //**************************************************************************
    //                              SETUP
    //**************************************************************************
    // default eye is left, to activate the right, add ?side=right to the url
    const minX = 15;            // %
    const maxX = 85;            // %
    const minY = 15;            // %
    const maxY = 85;            // %
    const rate = 1.4;
    const yRate = 1.3;
    const imageSize = 300;      // px
    const refreshDelay = 100;   // ms (poll period for /faces)
    //**************************************************************************
    //**************************************************************************

    const black = document.getElementById('black');
    const position = /(?:^|[?&])side=right(?:&|$)/.test(window.location.search) ? 'right' : 'left';

    black.style.width = `${imageSize}px`;
    black.style.height = `${imageSize}px`;

    function minMaxPct(value) {
        return Math.round(Math.min(100, Math.max(0, value)));
    }

    // --- ETag caching state (avoid downloading unchanged JSON) --------------
    let lastETag = null;
    let lastData = null;


    // --- Core: apply face box to move the image ------------------------------
    function applyDetections(data) {
        if (!data || !data.detections || !data.detections[0] || !data.detections[0].bbox) return;

        const { frame_width, frame_height } = data;
        const box = data.detections[0].bbox;

        // center of the face box
        const xCenter = box.x + box.width / 2;
        const yCenter = box.y + box.height / 2;

        // normalized to [-1..1] horizontally, with side bias factor
        let xNorm = -1 * 2 * ((xCenter / frame_width) - 0.5);
        if (xNorm < 0 && position === 'right') xNorm *= rate;
        if (xNorm > 0 && position === 'left')  xNorm *= rate;

        // normalized to [-1..1] vertically, with yRate amplification
        const yNorm = yRate * ((yCenter / frame_height) - 0.5);

        // convert to percentage within [min..max] range and center the image
        gsap.to(black, {
            left: `calc(${minMaxPct(minX + (maxX - minX) * ((xNorm + 1) / 2))}% - ${imageSize/2}px)`,
            top:  `calc(${minMaxPct(minY + (maxY - minY) * ((yNorm + 1) / 2))}% - ${imageSize/2}px)`,
            duration: 0.5,
            overwrite: true
        });
    }

    // --- Poll /faces forever (paused when tab hidden) ------------------------
    async function pollFaces() {
        while (true) {
            try {
                if (!document.hidden) {
                    const headers = {};
                    if (lastETag) headers['If-None-Match'] = lastETag;

                    const res = await fetch('/faces', { headers, cache: 'no-store' });

                    if (res.status === 200) {
                        const et = res.headers.get('ETag');
                        if (et) lastETag = et;

                        const data = await res.json();
                        lastData = data;
                        applyDetections(data); // update the screen on new data
                    } else if (res.status === 304 && lastData) {
                        // Not Modified: reuse last data to keep UI responsive
                        applyDetections(lastData);
                    } // else: ignore other statuses silently
                }
            } catch (e) {
                // Log once in a while; don't spam the console
                // console.warn('poll /faces failed:', e);
            }

            // Sleep between polls; if tab hidden, use a longer backoff
            await sleep(document.hidden ? Math.max(1000, refreshDelay * 2) : refreshDelay);
        }
    }

    function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }

    // Kick off polling
    pollFaces();
</script>
</body>
</html>